#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/wait.h>

int main(int argc, char *argv[])
{
    int rc = fork();
    if (rc < 0)
    {
        // fork failed
        fprintf(stderr, "fork failed\n");
        exit(1);
    }
    else if (rc == 0)
    {
        // child: redirect standard output to a file
        close(STDOUT_FILENO);
       // When you close STDOUT_FILENO, the child process's standard output is no longer directed to the terminal.
        //The next open() call opens the file a.out and assigns the file descriptor to STDOUT_FILENO.
        //This means that any subsequent writes to stdout (such as those generated by the wc command) will go to the file a.out instead of the terminal.
        //The open() call essentially redirects the output that would normally go to the terminal to the file a.out.
        open("./a.out", O_CREAT | O_WRONLY | O_TRUNC,
             S_IRWXU);
        // now exec "wc"...
        char *myargs[3];
        //The strdup() function allocates memory for the string and copies the content into it. This is necessary because the argument list that execvp() takes is an array of pointers to strings, and you need to ensure that the arguments are stored in memory that lasts until the execution of execvp().
        myargs[0] = strdup("wc");   // program: wc
        myargs[1] = strdup("calling_fork.c"); // arg: file to count
        myargs[2] = NULL;           // mark end of array
        execvp(myargs[0], myargs);  // runs word count
    }
    else
    {
        // parent goes down this path (main)
        int rc_wait = wait(NULL);
    }
    return 0;
}